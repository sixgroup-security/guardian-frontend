/**
 * This file is part of Guardian.
 *
 * Guardian is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Guardian is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Guardian. If not, see <https://www.gnu.org/licenses/>.
 *
 * @author Lukas Reiter
 * @copyright Copyright (C) 2024 Lukas Reiter
 * @license GPLv3
 */

import {
  ModelBase,
  GridColInputControlProps,
  StateContentTypes,
  isValidString,
  isValidBoolean,
  getBoolean,
  getArrayAutoCompleteEnumId,
  getSingleAutoCompleteEnumId,
  DataGridAutocompleteExtendedProps,
} from "./common";
import { URL_PATH_PREFIX } from "../util/consts/common";
import { MeasureLookup } from "./measure";
import { URL_PATH_TAGS_PREFIX } from "./project";
import { TagLookup } from "./tagging/tag";
import {
  CweLookup,
  queryKeyCweWeaknessTagsGeneral,
  URL_MITRE_CWE_WEAKNESS_LOOKUP,
} from "./tagging/mitreCwe";
import {
  queryKeyBugcrowdVrt,
  URL_BUGCROWD_VRT,
  VrtLookup,
} from "./tagging/bugcrowdVrt";
import {
  VrtRead,
  COLUMN_DEFINITION as VRT_COLUMN_DEFINITION,
} from "./tagging/bugcrowdVrt";
import {
  renderCellBugCrowdVrt as renderCell,
  valueGetterBugCrowdVrt as valueGetter,
} from "../pages/Common";
import { GridRowId } from "@mui/x-data-grid";

// Query keys for vulnerability templates
export const queryKeyVulnerabilityTemplates = ["vulnerability-templates"];
// Query keys for vulnerability template tags
export const queryKeyVulnerabilityTemplateTagsGeneral = [
  "vulnerability-tempate_tags",
  "general",
];

// Vulnerability template REST API endpoints
const URL_PATH_VULNERABILITY_TEMPLATES_PREFIX =
  URL_PATH_PREFIX + "/vulnerability-templates";
export const URL_VULNERABILITY_TEMPLATES_PREFIX =
  URL_PATH_VULNERABILITY_TEMPLATES_PREFIX;

// REST API endpoints for vulnerability template tags
const URL_PATH_VULNERABILITY_TEMPLATES_TAGS_PREFIX =
  URL_PATH_TAGS_PREFIX + "/vulnerabilities";
const URL_VULNERABILITY_TEMPLATE_TAGS_GENERAL =
  URL_PATH_VULNERABILITY_TEMPLATES_TAGS_PREFIX + "/general";
export const URL_TEMPLATE_PROCEDURES = URL_PATH_VULNERABILITY_TEMPLATES_PREFIX;

// Data grid settings for VRT's DataGridAutocomplete component
export const vrtDataGridAutoCompleteSettings: DataGridAutocompleteExtendedProps =
  {
    height: "350px",
    columns: VRT_COLUMN_DEFINITION,
    apiEndpoint: URL_BUGCROWD_VRT,
    queryKey: queryKeyBugcrowdVrt,
    getInitialValueFn: (value?: any) => {
      if (!value) {
        return [];
      } else if ("id" in value) {
        return [value.id];
      }
      return value;
    },
    filterFn: (row: any, uuids: GridRowId[]) => uuids?.includes(row.id) ?? [],
    convertFn: (data: any[]) => data.map((d) => new VrtRead(d)),
    getCellValueFn: valueGetter,
    renderCellFn: renderCell,
  };

// Valid types are: export type GridNativeColTypes = 'string' | 'number' | 'date' | 'dateTime' | 'boolean' | 'singleSelect' | 'actions';
export const COLUMN_DEFINITION: GridColInputControlProps[] = [
  {
    field: "id",
    hideColumn: true,
    controlType: null,
  },
  {
    field: "title",
    headerName: "Vulnerability Title",
    type: "string",
    description: "The title of the vulnerability identified by procedure.",
    errorText: "This field is required and cannot be empty.",
    width: 350,
    controlType: "TextField",
    required: true,
    uploadUrl: undefined,
    // hideColumn: true,
    multiLanguage: true,
    isValid(value: StateContentTypes) {
      return isValidString(value);
    },
  },
  /*{
    field: "objective",
    headerName: "Objective",
    hideColumn: true,
    type: "string",
    description: "Description of this test procedure's test objective.",
    errorText: "This field is required and cannot be empty.",
    controlType: "MarkdownEditor",
    required: true,
    minRows: 20,
    maxRows: 20,
    uploadUrl: undefined,
    multiLanguage: true,
    isValid(value: StateContentTypes) {
      return isValidString(value);
    },
  },*/
  {
    field: "description",
    headerName: "Description",
    type: "string",
    description:
      "Summary or introduction to test procedure's underlying vulnerability.",
    errorText: "This field is required and cannot be empty.",
    width: 350,
    controlType: "MarkdownEditor",
    markdownMaxHeight: "200px",
    required: true,
    uploadUrl: undefined,
    // hideColumn: true,
    multiLanguage: true,
    isValid(value: StateContentTypes) {
      return isValidString(value);
    },
  },
  {
    field: "observation",
    headerName: "Observation / Proof of Concept",
    type: "string",
    description:
      "Template text for the test procedure's observation or proof of concept.",
    width: 350,
    controlType: "MarkdownEditor",
    markdownMaxHeight: "500px",
    required: false,
    uploadUrl: undefined,
    // hideColumn: true,
    multiLanguage: true,
  },
  {
    field: "measures",
    headerName: "Measures",
    type: "string",
    description: "The mitigating measures for this procedure.",
    errorText: "This field is required and cannot be empty.",
    width: 350,
    controlType: "Autocomplete",
    required: false,
    multiSelect: true,
    getFinalValue(value: StateContentTypes) {
      const result = getArrayAutoCompleteEnumId(value);
      return result;
    },
  },
  {
    field: "references",
    headerName: "References",
    hideColumn: true,
    description: "Links to external resources.",
    controlType: "MarkdownEditor",
    markdownMaxHeight: "150px",
    required: false,
  },
  {
    field: "automate",
    headerName: "Automate",
    type: "boolean",
    description: "Specifies whether the vulnerability can be automated.",
    errorText: "The checkbox is currently undefined. Check or uncheck it.",
    headerAlign: "center",
    align: "center",
    width: 150,
    controlType: "Checkbox",
    required: true,
    isValid(value: StateContentTypes) {
      return isValidBoolean(value);
    },
    getFinalValue(value: StateContentTypes) {
      return getBoolean(value);
    },
  },
  {
    field: "rating_count",
    headerName: "No. Ratings",
    type: "number",
    description: "Number of ratings associated with this vulnerability.",
    controlType: "TextField",
  },
  {
    field: "vrt",
    headerName: "VRT Category",
    type: "string",
    description:
      "The BugCrowd VRT category to which this vulnerability belongs.",
    width: 350,
    controlType: "DataGridAutocomplete",
    freeSolo: false,
    multiSelect: false,
    dataGridAutoCompleteSettings: vrtDataGridAutoCompleteSettings,
    getFinalValue(value: StateContentTypes) {
      const tmp = value ?? [];
      return tmp.length > 0 ? tmp[0] : null;
    },
  },
  {
    field: "cwe_weakness",
    headerName: "CWE Weakness",
    type: "string",
    description: "The CWE weakness to which this vulnerability belongs.",
    width: 350,
    controlType: "Autocomplete",
    apiEndpoint: URL_MITRE_CWE_WEAKNESS_LOOKUP,
    queryKey: queryKeyCweWeaknessTagsGeneral,
    freeSolo: false,
    multiSelect: false,
    getFinalValue(value: StateContentTypes) {
      return getSingleAutoCompleteEnumId(value);
    },
  },
  {
    field: "general_tags",
    headerName: "Tags",
    type: "string",
    description: "General tags for the vulnerability template.",
    width: 350,
    controlType: "Autocomplete",
    apiEndpoint: URL_VULNERABILITY_TEMPLATE_TAGS_GENERAL,
    queryKey: queryKeyVulnerabilityTemplateTagsGeneral,
    freeSolo: true,
    multiSelect: true,
    getFinalValue(value: StateContentTypes) {
      return getArrayAutoCompleteEnumId(value);
    },
  },
];

export class VulnerabilityTemplateRead extends ModelBase {
  public references: string;
  public automate: boolean;
  public measures: MeasureLookup[];
  public title: { [key: string]: string };
  // public objective: { [key: string]: string };
  public description: { [key: string]: string };
  public observation: { [key: string]: string };
  public rating_count: number;
  public cwe_weakness?: CweLookup;
  public general_tags: TagLookup[];
  public vrt?: VrtLookup;

  constructor(userData: any) {
    super(userData.id);
    this.references = userData.references;
    this.automate = userData.automate;
    this.measures =
      userData.measures?.map((item: any) => new MeasureLookup(item)) ?? [];
    this.title = userData.title;
    this.description = userData.description;
    this.observation = userData.observation;
    this.rating_count = userData.rating_count;
    this.vrt = userData.vrt;
    this.cwe_weakness = userData.cwe_weakness
      ? new CweLookup(userData.cwe_weakness)
      : undefined;
    this.general_tags = userData.general_tags ?? [];
  }
}
