/**
 * This file is part of Guardian.
 *
 * Guardian is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Guardian is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MyAwesomeProject. If not, see <https://www.gnu.org/licenses/>.
 *
 * @author Lukas Reiter
 * @copyright Copyright (C) 2024 Lukas Reiter
 * @license GPLv3
 */

import {
  NamedModelBase,
  GridColInputControlProps,
  isValidString,
  StateContentTypes,
  isValidNumber,
  getNumber,
  getBoolean,
  isNotNullUndefined,
  getSingleAutoCompleteEnumId,
  isValidCvss,
} from "./common";
import {
  SeverityType,
  VulnerabilityStatus,
  getAutoCompleteOption,
  getEnumNames,
} from "./enums";
import { VrtLookup } from "./tagging/bugcrowdVrt";
import {
  CweLookup,
  queryKeyCweWeaknessTagsGeneral,
  URL_MITRE_CWE_WEAKNESS_LOOKUP,
} from "./tagging/mitreCwe";
import { vrtDataGridAutoCompleteSettings } from "./vulnerabilityTemplate";

export const queryKeyVulnerabilities = ["vulnerability"];

// Valid types are: export type GridNativeColTypes = 'string' | 'number' | 'date' | 'dateTime' | 'boolean' | 'singleSelect' | 'actions';
export const COLUMN_DEFINITION: GridColInputControlProps[] = [
  {
    field: "id",
    hideColumn: true,
    controlType: null,
  },
  {
    field: "source_template_id",
    hideColumn: true,
    controlType: null,
    noSubmit: true,
  },
  {
    field: "has_pdf",
    hideColumn: true,
    controlType: null,
    noSubmit: true,
  },
  {
    field: "has_pdf_log",
    hideColumn: true,
    controlType: null,
    noSubmit: true,
  },
  {
    field: "has_tex",
    hideColumn: true,
    controlType: null,
    noSubmit: true,
  },
  {
    field: "vulnerability_id_str",
    headerName: "ID",
    type: "string",
    description: "The ID of the vulnerability.",
    errorText: "This field is required and cannot be empty.",
    width: 250,
    controlType: "TextField",
    readonly: true,
    required: false,
  },
  {
    field: "name",
    headerName: "Title",
    type: "string",
    description: "The title of the vulnerability.",
    errorText: "This field is required and cannot be empty.",
    width: 250,
    controlType: "TextField",
    required: true,
    isValid(value: StateContentTypes) {
      return isValidString(value);
    },
  },
  {
    field: "status",
    headerName: "Status",
    type: "singleSelect",
    valueOptions: getEnumNames(VulnerabilityStatus),
    description: "The vulnerability's reporting status.",
    errorText: "This field is required and cannot be empty.",
    headerAlign: "center",
    align: "center",
    width: 100,
    controlType: "Autocomplete",
    required: true,
    isValid(value: StateContentTypes) {
      return isNotNullUndefined(value);
    },
    getFinalValue(value: StateContentTypes) {
      return getSingleAutoCompleteEnumId(value);
    },
  },
  {
    field: "severity",
    headerName: "Severity",
    type: "singleSelect",
    valueOptions: getEnumNames(SeverityType),
    description: "The vulnerability's severity.",
    errorText: "This field is required and cannot be empty.",
    headerAlign: "center",
    align: "center",
    width: 100,
    controlType: "Autocomplete",
    required: false,
    /*isValid(value: StateContentTypes) {
      return isNotNullUndefined(value);
    },*/
    getFinalValue(value: StateContentTypes) {
      return getSingleAutoCompleteEnumId(value);
    },
  },
  {
    field: "description",
    headerName: "Description",
    type: "string",
    description: "A general description about vulnerability.",
    errorText: "This field is required and cannot be empty.",
    width: 250,
    controlType: "MarkdownEditor",
    markdownEditorMode: "Popout",
    markdownMaxHeight: "300px",
    required: false,
    /*isValid(value: StateContentTypes) {
      return isValidString(value);
    },*/
  },
  {
    field: "observation",
    headerName: "Observation / Proof of Concept",
    type: "string",
    description: "The detailed proof that the vulnerability exists.",
    errorText: "This field is required and cannot be empty.",
    width: 250,
    controlType: "MarkdownEditor",
    markdownEditorMode: "Popout",
    markdownMaxHeight: "600px",
    required: false,
    /*isValid(value: StateContentTypes) {
      return isValidString(value);
    },*/
  },
  {
    field: "measure_title",
    headerName: "Measure Title",
    type: "string",
    description: "The countermeasure's title.",
    errorText: "This field is required and cannot be empty.",
    width: 250,
    controlType: "TextField",
    required: false,
    /*isValid(value: StateContentTypes) {
      return isValidString(value);
    },*/
  },
  {
    field: "measure_recommendation",
    headerName: "Measure Recommendation",
    type: "string",
    description: "The countermeasure's detailed recommendation.",
    errorText: "This field is required and cannot be empty.",
    width: 250,
    controlType: "MarkdownEditor",
    markdownEditorMode: "Popout",
    markdownMaxHeight: "300px",
    required: false,
    /*isValid(value: StateContentTypes) {
      return isValidString(value);
    },*/
  },
  {
    field: "references",
    headerName: "References",
    type: "string",
    description: "List of links to additional information.",
    errorText: "This field is required and cannot be empty.",
    width: 250,
    controlType: "MarkdownEditor",
    markdownEditorMode: "Popout",
    markdownMaxHeight: "150px",
    required: false,
  },
  {
    field: "cvss_score",
    headerName: "CVSS Score",
    type: "number",
    description: "The vulnerability's CVSS Score.",
    errorText: "This field can be empty or must be a number.",
    headerAlign: "center",
    align: "center",
    width: 100,
    controlType: "TextField",
    required: false,
    isValid(value: StateContentTypes) {
      return (
        (value === null || value === undefined || isValidNumber(value)) &&
        value >= 0 &&
        value <= 10
      );
    },
    getFinalValue(value: StateContentTypes) {
      return getNumber(value);
    },
  },
  {
    field: "cvss_vector",
    headerName: "CVSS Vector",
    type: "string",
    description: "The vulnerability's CVSS vector string.",
    width: 300,
    controlType: "TextField",
    required: false,
    isValid(value: StateContentTypes) {
      return isValidCvss(value) || value === null || value === undefined;
    },
  },
  {
    field: "rating_comment",
    headerName: "Rating Comment",
    hideColumn: true,
    type: "string",
    description: "Background information for rating.",
    controlType: "MarkdownEditor",
    markdownEditorMode: "Popout",
    markdownMaxHeight: "150px",
    required: false,
    minRows: 4,
    maxRows: 4,
    uploadUrl: undefined,
  },
  {
    field: "vrt",
    headerName: "VRT Category",
    type: "string",
    description:
      "The BugCrowd VRT category to which this vulnerability belongs.",
    width: 350,
    controlType: "DataGridAutocomplete",
    freeSolo: false,
    multiSelect: false,
    dataGridAutoCompleteSettings: vrtDataGridAutoCompleteSettings,
    getFinalValue(value: StateContentTypes) {
      const tmp = value ?? [];
      return tmp.length > 0 ? tmp[0] : null;
    },
  },
  {
    field: "cwe_weakness",
    headerName: "CWE Weakness",
    type: "string",
    description: "The CWE weakness to which this vulnerability belongs.",
    width: 350,
    controlType: "Autocomplete",
    apiEndpoint: URL_MITRE_CWE_WEAKNESS_LOOKUP,
    queryKey: queryKeyCweWeaknessTagsGeneral,
    freeSolo: false,
    multiSelect: false,
    getFinalValue(value: StateContentTypes) {
      return getSingleAutoCompleteEnumId(value);
    },
  },
  {
    field: "cwe_category",
    headerName: "CWE Category",
    type: "string",
    description: "Legacy column containing the vulnerability's CWE category.",
    width: 200,
    controlType: "TextField",
    required: false,
    noSubmit: true,
  },
  {
    field: "template_candidate",
    headerName: "Template Candidate",
    type: "boolean",
    description: "Mark vulnerability as potential template candidate.",
    errorText: "The checkbox is currently undefined. Check or uncheck it.",
    headerAlign: "center",
    align: "center",
    width: 150,
    controlType: "Checkbox",
    required: false,
    getFinalValue(value: StateContentTypes) {
      return getBoolean(value);
    },
  },
];

export class VulnerabilityRead extends NamedModelBase {
  public vulnerability_id_str: string;
  public description: string;
  public observation: string;
  public measure_title: string;
  public measure_recommendation: string;
  public references: string;
  public cvss_score: string;
  public cvss_vector: string;
  public severity: { id: SeverityType; label: string } | null;
  public rating_comment: string;
  public vrt?: VrtLookup;
  public cwe_weakness?: CweLookup;
  public cwe_category?: string;
  public template_candidate: boolean;
  public status: { id: VulnerabilityStatus; label: string } | null;
  public source_template_id: string;
  public has_pdf: boolean;
  public has_pdf_log: boolean;
  public has_tex: boolean;

  constructor(userData: any) {
    super(userData.name, userData.id);
    this.vulnerability_id_str = userData.vulnerability_id_str;
    this.description = userData.description;
    this.observation = userData.observation;
    this.measure_title = userData.measure_title;
    this.measure_recommendation = userData.measure_recommendation;
    this.references = userData.references;
    this.cvss_score = userData.cvss_score;
    this.cvss_vector = userData.cvss_vector;
    this.severity =
      typeof userData.severity === "number"
        ? getAutoCompleteOption(SeverityType, userData.severity)
        : userData.severity;
    this.rating_comment = userData.rating_comment;
    this.vrt = userData.vrt;
    this.cwe_weakness = userData.cwe_weakness;
    this.cwe_category = userData.cwe_category ?? "";
    this.template_candidate = userData.template_candidate;
    this.status =
      typeof userData.status === "number"
        ? getAutoCompleteOption(VulnerabilityStatus, userData.status)
        : userData.status;
    this.source_template_id = userData.source_template_id;
    this.has_pdf = userData.has_pdf;
    this.has_pdf_log = userData.has_pdf_log;
    this.has_tex = userData.has_tex;
  }
}

export class Vulnerability extends VulnerabilityRead {
  constructor(userData: any) {
    super(userData);
  }

  getMarkdown(template: string) {
    // TODO: Improve markdown rendering (e.g., if one of the fields contains markdown syntax)
    return template
      .replace("{{.title}}", this.name)
      .replace("{{.id}}", this.vulnerability_id_str)
      .replace(
        "{{.resolved}}",
        this.status?.id === VulnerabilityStatus.Resolved ? "[Resolved]" : ""
      )
      .replace("{{.cvss_score}}", this.cvss_score ?? "")
      .replace("{{.cvss_vector}}", this.cvss_vector ?? "")
      .replace("{{.severity}}", this.severity?.label ?? "")
      .replace("{{.description}}", this.description)
      .replace("{{.measure_title}}", this.measure_title)
      .replace("{{.rating_comment}}", this.rating_comment ?? "")
      .replace("{{.references}}", this.references ?? "")
      .replace("{{.recommendation}}", this.measure_recommendation)
      .replace("{{.observation}}", this.observation);
  }
}
